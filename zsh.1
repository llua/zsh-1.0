.TH ZSH 1
.SH NAME
zsh \- the Z shell
.SH SYNTAX
\fBzsh\fP
[
.B \-aefikmnstuvx0123456789ABCDEFGHIJK
] [
.B \-c
string ]
[ arg .\|.\|. ]
.SH DESCRIPTION
\fBzsh\fP
is a command interpreter and programming language
that executes commands read from a terminal
or a file.
See
.B Invocation
for the meanings of arguments to \fBzsh\fP.
.SS Definitions
A metacharacter can one of the following characters:
.RS
.PP
\fB;   &   (   )   {   }   \(bv   <   >   blank   newline\fP
.RE
.PP
A blank is a
.B tab
or a
.BR space .
An identifier
is a sequence of letters, digits, or underscores
starting with a letter or underscore.
Identifiers are used as names for
`named parameters'.
A word is a sequence of
characters separated by one or more non-quoted
metacharacters.
.PP
A command
is a sequence of characters in the syntax
of the shell language.
\fBzsh\fP reads each command and
carries out the desired action either directly or by invoking
separate utilities.
A builtin is a command that is carried out by the
parent shell without creating a separate process.
.SS Commands
A simple-command is a sequence of blank
separated words
which may be preceded by a parameter assignment list.
See
.B Environment
below.
The first word specifies the name of the command to
be executed.
Except as specified below,
the remaining words are passed as arguments
to the invoked command.
The command name is passed as argument 0
(see
.BR exec (2)).
The value of a simple-command is its exit status
if it terminates normally, or (octal) 200+\fIstatus\^\fP if
it terminates abnormally (see
.B signal
for a list of
status values).
.PP
A pipeline
is a sequence of one or more
commands
separated by
.B \(bv
or
.B \(bv&
("\fB\(bv&\fP" is actually shorthand for "\fB2>&1\ \|\(bv\fP\|".  See
.B Input/Output
below).
The standard output of each command but the last
is connected by a
.B pipe 
to the standard input of the next command.
Each command is run as a separate process;
\fBzsh\fP waits for all the commands to terminate.
The exit status of a pipeline is the exit
status of the last command to terminate.  A pipeline may be preceded by
one of the following keywords:
.PP
.PD 0
.TP
\fBtime\fP
The user, system, and real times
of the commands in the pipeline are printed when the pipeline
completes.
.TP
\fBcoproc\fP
The processes are
run asynchronously with the input and output of the pipeline
connected to a two-way pipe to the parent shell.  The parent
communicates with the coprocess using the \fB>&p\fP
and \fB<&p\fP redirection operators.
.TP
\fB!\fP
The exit status of the pipeline is the boolean NOT of the
exit status of the last command.
.PD
.PP
A sublist is a sequence of one or more pipelines
separated by
.BR &&
or
.BR || .
The symbol \fB&&\fP (\fB||\fP) causes the list following it to be
executed only if the preceding pipeline returns
a zero (non-zero) value.
.PP
A list is a sequence of one or more sublists separated
by, and optionally terminated by, either
.BR ;
or
.BR & .
A \fB;\fP causes sequential execution of the preceding
sublist; a \fB&\fP causes asynchronous execution of the preceding
sublist (that is, it does not wait for that sublist to finish).
An arbitrary number of newlines may appear in a
list, instead of a semicolon,
to delimit a command.
.PP
A command
is either a simple-command
or one of the following.
Unless otherwise stated,
the value returned by a command is that of the
last simple-command executed in the command.
.TP
\fBfor\fP \fIidentifier\^\fP [ \fBin\fP \fIword\^\fP .\|.\|. ] \fB;do\fP \fIlist\^\fP \fB;done\fP
Each time a
.B for
command is executed, 
.I identifier 
is set to the next 
.I word 
taken from the
.B in
.I word list.
If
.B in 
.I word
\&.\|.\|.
is omitted, then the
.B for
command executes the \fBdo\fP \fIlist\^\fP once for each positional parameter
that is set
(see \fB"Parameter Substitution"\fP).
Execution ends when there are no more words in the list.
.TP
\fBselect\fP \fIidentifier\^\fP [ \fBin\fP \fIword\^\fP .\|.\|. ] \fB;do\fP \fIlist\^\fP \fB;done\fP
A
.B select
command prints on standard error (file descriptor 2), the set of
.IR word s,
each preceded by a number.
If
.BI in " word"
\&.\|.\|.
is omitted, then the positional parameters are used instead
(see
.B "Parameter Substitution"
below).
The
.B PROMPT3
prompt is printed
and a line is read from the standard input.
If this line consists of the number
of one of the listed
.IR word s,
then the value of the parameter
.I identifier
is set to the
.I word
corresponding to this number.
If this line is empty the selection list is
printed again.
Otherwise the value of the parameter
.I identifier
is set to null.  The contents of the line read from standard input is
saved in the parameter \fBREPLY\fP.  The
.I list
is executed for each selection until a
break or end-of-file is encountered.
.TP
\fBcase\fP \fIword\^\fP \fBin\fP [ \fIpattern\^\fP \fB)\fP \fIlist\^\fP \fB;;\fP ] .\|.\|. \fBesac\fP
A
.B case
command executes the
.I list
associated with the first
.I pattern
that matches
.IR word .
The form of the patterns is
the same as that used for
filename generation (see
.B "Filename Generation"
below).
.TP
\fBif\fP \fIlist\^\fP \fB;then\fP \fIlist\^\fP [ \
\fBelif\fP \fIlist\^\fP \fB;then\fP \fIlist\^\fP ] .\|.\|. \
[ \fB;else\fP \fIlist\^\fP ] \fB;f\&i\fP
The
.I list
following \fBif\fP is executed and,
if it
returns a zero exit status, the
.I list
following the first
.B then
is executed.  Otherwise, the
.I list
following \fBelif\fP
is executed and, if its value is zero, the
.I list
following the next
.B then
is executed.  Failing that, the
.B else
.I list
is executed.  If no
.B else
.I list
or
.B then
.I list
is executed, then the
.B if
command returns a zero exit status.
.TP
.PD 0
\fBwhile\fP \fIlist\^\fP \fB;do\fP \fIlist\^\fP \fB;done\fP
.TP
\fBuntil\fP \fIlist\^\fP \fB;do\fP \fIlist\^\fP \fB;done\fP
.PD
A
.B while
command repeatedly executes the
.B while
.I list
and, if the exit status of the last command in the list is zero, executes
the
.B do
.IR list ;
otherwise the loop terminates.
If no commands in the
.B do
.I list
are executed, then the
.B while
command returns a zero exit status;
.B until
may be used in place of
.B while
to negate
the loop termination test.
.TP
\fBrepeat\fP \fInum\fP\fB ;do\fP \fIlist\^\fP \fB;done\fP
A
.B repeat
command executes the
.I list
a certain number of times, as specified by
.IR num .
If the exit status of
.I list
is nonzero, the loop terminates.
.TP
\fB(\fP\fIlist\^\fP\fB)\fP
Execute
.I list
in a separate environment.
Note, that if two adjacent open parentheses are
needed for nesting, a space must be inserted to avoid
arithmetic evaluation as described below.
.TP
\fB{\fP\fIlist\^\fP\fB}\fP
The 
.I list
is simply executed.
.TP
.PD 0
\fBfunction\fP \fIidentifier\^\fP \fB{\fP\fIlist\fB}\fP
.TP
\fIidentifier\^\fP \fB() {\fP\fIlist\fB}\fP
.PD
Define a function which is referenced by
.IR identifier .
The body of the function is the
.I list
of commands between
.B {
and
.BR } .
(See
.B Functions
below).
.TP
\fBexec \fP\fIcommand\^\fP
.br
The
.I command
is executed in place of the parent shell, without forking.
.TP
\fBcommand \fP\fIcommand\^\fP
.br
The
.I command
is run, ignoring shell functions.
.PP
The following reserved words
are only recognized as the first word of a command
and when not quoted:
.RS
.PP
.B
if then else elif fi case esac for while until do done repeat function select time coproc ! exec command
.RE
.SS History Substitution
.LP
History substitution allows you to use words from previous command
lines in the command line you are typing.  This simplifies spelling
corrections and the repetition of complicated commands or arguments.
Command lines are saved in the history list, the size of which
is controlled by the
.B HISTSIZE
variable.  The most recent command is retained in any case.
A history substitution begins with a
.B !
and may occur anywhere on the command line; history
substitutions do not nest.  The
.B !
can be escaped with
.B \e
to suppress its special meaning.
.LP
Input lines containing history substitutions are echoed on the
terminal after being expanded, but before any other
substitutions take place or the command gets executed.
.SS \fIEvent Designators\fP
.LP
An event designator is a reference to a command-line entry in
the history list.
.RS
.PD 0
.TP
.B !
Start a history substitution, except when followed by a blank, newline,
.BR = ,
or
.BR ( .
.TP
.B !!
Refer to the previous command. 
By itself, this substitution
repeats the previous command.
.TP
.BI ! n
Refer to command-line
.IR n .
.TP
.BI ! \-n
Refer to the current command-line minus
.IR n .
.TP
.BI  ! str
Refer to the most recent command starting with
.IR str .
.TP
.BI  !? str\fR[\fP ? \fR]\fP
Refer to the most recent command containing
.IR str .
.TP
.B !#
Refer to the current command line typed in so far.
.TP
.BR !{ .\|.\|. }
Insulate a history reference from adjacent characters (if necessary).
.PD
.RE
.SS \fIWord Designators\fR
.LP
A
.RB ` : '
separates the event specification from the word designator. 
It can be omitted if the word designator begins with a
.BR \*^ ,
.BR $ ,
.BR * ,
.B \-
or
.BR % .
If the word is to be selected from the previous command, the second
.B !
character can be omitted from the event specification.  For instance,
.B !!:1
and
.B !:1
both refer to the first word of the previous command, while
.B !!$
and
.B !$
both refer to the last word in the previous command. 
Word designators include:
.RS
.PD 0
.TP
.B 0
The first input word (command).
.TP
.I n
The
.IR n 'th
argument.
.TP
.B ^
The first argument, that is,
.BR 1 .
.TP
.B $
The last argument.
.TP
.B %
The word matched by (the most recent)
.BI ? s
search.
.TP
.IB x \- y
A range of words;
.BI \- y
abbreviates
.BI 0\- y\fR.
.TP
.B *
All the arguments, or a null value if there is just
one word in the event.
.TP
.IB x *
Abbreviates
.IB x \-$ .
.TP
.IB x \-
Like
.I x*
but omitting word
.BR $ .
.PD
.RE
.SS \fIModifiers\fR
.IX "history substitution modifiers"
.IX ": modifiers" "" "\fL:\fR modifiers \(em history substitution \(em \fLcsh\fR"
.LP
After the optional word designator, you can add
a sequence of one or more of the following modifiers,
each preceded by a
.BR : .
.RS
.TP
.B h
Remove a trailing pathname component, leaving the head.
.PD 0
.TP
.B r
Remove a trailing suffix of the form
.RB ` "\&.\fIxxx" ',
leaving the basename.
.TP
.B e
Remove all but the suffix.
.TP
.BI s/ l / r\fR[\fP / \fR]\fP
Substitute
.I r
for
.IR l .
.TP
.B t
Remove all leading pathname components, leaving the tail.
.TP
.B &
Repeat the previous substitution.
.TP
.B g
Apply the change to the first occurrence of a match in each word,
by prefixing the above (for example,
.BR g& ).
.TP
.B p
Print the new command but do not execute it.
.TP
.B q
Quote the substituted words, escaping further substitutions.
.TP
.B x
Like
.BR q ,
but break into words at each blank.
.PD
.RE
.LP
Unless preceded by a
.BR g ,
the modification is applied only to the
first string that matches
.IR l ;
an error results if no string matches.
.LP
The left-hand side of substitutions are not regular expressions,
but character strings.
Any character can be used as the delimiter in place of
.BR / .
A backslash quotes the delimiter character.
The character
.BR & ,
in the right hand side, is replaced by the text
from the left-hand-side. 
The
.B &
can be quoted with a backslash. 
A null
.I l
uses the previous string either from a
.I l
or from a contextual scan string
.I s
from
.BI !? s\fR.
You can omit the rightmost delimiter if a newline
immediately follows
.IR r ;
the rightmost
.B ?
in a context scan can similarly be omitted.
.LP
Without an event specification, a history reference refers either to the
previous command, or to a previous history reference on the command line
(if any).
.PP
.LP
.PP
The character sequence
.BI ^ foo ^ bar
repeats the last command, replacing the string "foo" with the
string "bar".
.PP
If \fBzsh\fP encounters the character sequence
\fB!"\fP
in the input, the history mechanism is temporarily disabled until
the current list is fully parsed.  The
\fB!"\fP
is removed from the input, and any subsequent
.B !
characters have no special significance.
.PP
A less convenient but more comprehensible
form of command history support
is provided by the
.B fc
builtin (see below).
.SS Comments
In noninteractive shells,
a word beginning with
.B #
causes that word and all the following characters up to a newline
to be ignored.
.SS Aliasing
The first word of each command is replaced by the text of an
alias if an alias for this word has been defined.  
The replacement string can contain any
valid input
including the metacharacters listed above.
If the last character of the alias value is a blank
then the word following the alias will also be checked for alias
substitution.
Aliases can be nested.
If an alias is defined with using the \-a flag (see the
.B alias
builtin below), it will be replaced no matter where it
appears in the command line.
Aliases can be used to redefine 
builtin commands or the
`reserved words' listed above.
Aliases can be created and listed with the
alias
command and can be removed with the
unalias
command.
.PP
The following aliases
are compiled into \fBzsh\fP
but can be unset or redefined:
.RS 5
.PD 0
.TP
.B "false=\(fmlet 0\(fm"
.TP
.B "history=\(fmfc \-l\(fm"
.TP
.B "nohup=\(fmnohup\ \(fm"
.TP
.B "r=\(fmfc \-e \-\(fm"
.TP
.B "true=\(fm:\(fm"
.TP
.B "pwd=\(fmecho $PWD\(fm"
.PD
.RE
.SS Process Substitution
Each command argument of the form
\fB<(\fP\fIlist\^\fP\fB)\fP
or
\fB>(\fP\fIlist\^\fP\fB)\fP
or
\fB=(\fP\fIlist\^\fP\fB)\fP
is subject to process substitution.
In the case of the
.B <
or
.B >
forms, \fBzsh\fP
will run process
.I list
asynchronously connected to a named pipe (FIFO).
The name of this pipe will become the argument to the command.
If the form with
.B >
is selected then writing on this file will provide input for
.IR list .
If
.B <
is used,
then the file passed as an argument will
be a named pipe connected to the output of the
.I list
process.
For example,
.RS
.PP
\fBpaste <(cut \-f1\fP \fIfile1\fP\fB) <(cut \-f3\fP \fIfile2\fB) | tee >(\fP\fIprocess1\fP\fB) >(\fP\fIprocess2\fP\fB)\fP >/dev/null
.RE
.PP
.BR cut s
fields 1 and 3 from
the files
.I file1
and
.I file2
respectively,
.BR paste s
the results together, and sends it to the processes
.I process1
and
.IR process2 .
Note that the file, which is passed as an argument to the command,
is a system
pipe 
so programs that expect to
.BR lseek (2)
on the file will not work.
Also note that the previous example can be more compactly and
efficiently written as:
.RS
.PP
\fBpaste <(cut \-f1\fP \fIfile1\fP\fB) <(cut \-f3\fP \fIfile2\fB) > >(\fP\fIprocess1\fP\fB) > >(\fP\fIprocess2\fP\fB)\fP
.RE
.PP
\fBzsh\fP uses socketpairs (pipes) instead of a FIFOs to implement the latter
two process substitutions in the above example.
.PP
If
.B =
is used,
then the file passed as an argument will be the name
of a temporary file containing
the output of the
.I list
process.  This may be used instead of the
.B <
form for a program that expects to lseek on the input file.
.SS Parameter Substitution
A parameter is an identifier,
one or more digits,
or any of the characters
.BR \(** ,
.BR # ,
.BR ? ,
.BR \- ,
.BR $ ,
and
.BR !\\^ .
The value of a named
parameter may also be assigned by writing:
.RS
.PP
.IB name = value\^\|
[
.IB name = value
] .\|.\|.
.RE
.PP
If
.I name
was declared integer with the
.B integer
builtin, the
.I value
is subject to arithmetic evaluation as described below.
.PP
Positional parameters,
parameters denoted by a number,
may be assigned values with the
\fBset\fP
builtin.  Parameter
.B $0
is set from argument zero when \fBzsh\fP
is invoked.
.PP
The character
.B $
is used to introduce parameter substitution.
Note that the results of such
substitution are quoted from all
further substitution.
.PP
.PD 0
.RS
.TP
\fB${\fP\fIparameter\^\fP\fB}\fP
The value, if any, of the parameter is substituted.
The braces are required when
.I parameter
is followed by a letter, digit, or underscore
that is not to be interpreted as part of its name
or when a named parameter is subscripted.
If
.I parameter
is one or more digits then it is a positional parameter.
.I parameter
may be followed by zero or more of any of the modifiers allowed in the
history mechanism except \fBq\fP and \fBx\fP.
.TP
\fB$*\fP
All the positional
parameters, starting with
.BR $1 ,
are substituted.
.TP
\fB${\fP\fIparameter\^\fP\fB:\-\fP\fIword\^\fP\fB}\fP
If
.I parameter
is set and is non-null then substitute its value;
otherwise substitute
.IR word .
.TP
\fB${\fP\fIparameter\^\fP\fB:=\fP\fIword\^\fP\fB}\fP
If
.I parameter
is not set or is null then set it to
.IR word ;
the value of the parameter is then substituted.
Positional parameters may be assigned to
in this way.
.TP
\fB${\fP\fIparameter\^\fP\fB:?\fP\fIword\^\fP\fB}\fP
If
.I parameter
is set and is non-null then substitute its value;
otherwise, print
.I word
and exit.
If
.I word
is omitted then a standard message is printed.
.TP
\fB${\fP\fIparameter\^\fP\fB:+\fP\fIword\^\fP\fB}\fP
If
.I parameter
is set and is non-null then substitute
.IR word ;
otherwise substitute nothing.
.TP
\fB${\fP\fIparameter\^\fP\fB#\fP\fIpattern\^\fP\fB}\fP
.TP
\fB${\fP\fIparameter\^\fP\fB##\fP\fIpattern\^\fP\fB}\fP
If the shell
.I pattern
matches the beginning of the value of
.IR parameter ,
then the value of
this substitution is the value of the
.I parameter
with the matched portion deleted;
otherwise the value of this
.I parameter
is substituted.
In the first form the smallest matching pattern is deleted and in the
second form the largest matching pattern is deleted.
.TP
\fB${\fP\fIparameter\^\fP\fB%\fP\fIpattern\^\fP\fB}\fP
.TP
\fB${\fP\fIparameter\^\fP\fB%%\fP\fIpattern\^\fP\fB}\fP
If
the shell
.I pattern
matches the end of the value of
.IR parameter ,
then the value of
this substitution is the value of the
.I parameter
with the matched part deleted;
otherwise substitute the value of
.IR parameter .
In the first form the smallest matching pattern is deleted and in the
second form the largest matching pattern is deleted.
.PD
.RE
.PP
In the above,
.I word
is not evaluated unless it is
to be used as the substituted string,
so that, in the following example,
pwd
is executed only if
.B d
is not set or is null:
.RS
.PP
.B "echo \|${d:\-\^$(\^pwd\^)\^}"
.RE
.PP
If the
.B :
is omitted from the above expressions,
then \fBzsh\fP only checks whether
.I parameter
is set or not.
.PP
The following parameters are automatically set by \fBzsh\fP:
.RS
.PD 0
.TP 10
.B #
The number of positional parameters in decimal.
.TP
.B \-
Flags supplied to \fBzsh\fP on invocation or by
the
.B setopt
command.
.TP
.B ?
The decimal value returned by the last executed command.
.TP
.B $
The process number of this shell.
.TP
.B !
The process number of the last background command invoked.
.TP
.B EUID
The effective user id of the shell process.
.TP
.B HOSTTYPE
A string corresponding to the architecture \fBzsh\fP is running on.
.TP
.B PPID
The process number of the parent of this shell.
.TP
.B PWD
The present working directory set by the
cd
command.
.TP
.B RANDOM
Each time this parameter is referenced, a random integer,
uniformly distributed between 0 and 32767, is generated.
The sequence of random numbers can be initialized by assigning
a numeric value to
RANDOM.
.TP
.B LINENO
In a script, the current line number.
.TP
.B REPLY
This parameter is set by the
.B select
statement and by
the
.B read
builtin when no arguments are supplied.
.TP
.B SECONDS
Each time this parameter is referenced, the number of
seconds since shell invocation is returned.
If this parameter is
assigned a value, then the value returned upon reference will
be the value that was assigned plus the number of seconds since the assignment.
.TP
.B TCxx
The string or value corresponding to the termcap entry \fBxx\fP.
.TP
.B UID
The user id of the shell process.
.TP
.B USERNAME
The name corresponding to the real user id of this shell process.
.TP
.B VERSION
The version number of this \fBzsh\fP.
.PD
.RE
.PP
The following parameters are used by \fBzsh\fP:
.RS
.PD 0
.TP
.B ARGV0
If placed in the environment for a command, \fBzsh\fP
will use its value as argv[0] for the \fBexec\fP(2) call
rather than the specified command name.
.TP
.B CDPATH
The search path for the
cd
command.
.TP
.B FCEDIT
The default editor name for the
.B fc
command.
.TP
.B IFS
Internal field separators,
normally
.BR space ,
.BR tab ,
and
.B newline
that is used to separate command words which result from
command or parameter substitution
and for separating words with the 
.B read
builtin.
.TP
.B HISTSIZE
If this parameter is set when \fBzsh\fP is invoked, then
the number of previously entered commands that
are accessible by this shell
will be greater than or equal to this number.
The default is 128.
.TP
.B HOME
The default argument (home directory) for the
.B cd
command.
.TP
.B MAIL
If this parameter is set to the name of a mail file
then \fBzsh\fP informs the user of arrival of mail
in the specified file.
.TP
.B MAILCHECK
This variable specifies how often (in seconds) \fBzsh\fP
will check for changes in the modification time
of any of the files specified by the
.B MAIL
parameter.
The default value is 60 seconds.
When the time has elapsed
\fBzsh\fP will check before issuing the next prompt.
.TP
.B PROMPT
The value of this parameter is expanded
much like printf(3S),
using "%<char>" to signal an expansion.
The available sequences are:
.RS
.PP
.TP
.B %d \fPor\fB %/
The current working directory.
.TP
.B %\(ap
The current working directory; if it starts with $HOME, that part is 
replaced by a \(ap.
.TP
.B %c \fPor\fB %.
The trailing component of the current working directory.
.TP
.B %h \fPor\fB %!
The current history event number.
.TP
.B %M
The full machine hostname.
.TP
.B %m
The hostname up to the first ".".
.TP
.BR %S\  ( %s )
Start (stop) standout mode.
.TP
.BR %B\  ( %b )
Start (stop) boldfacing mode.
.TP
.BR %U\  ( %u )
Start (stop) underline mode.
.TP
.B %t \fPor\fB %@
Current time of day, in 12-hour, am/pm format.
.TP
.B %T
Current time of day, in 24-hour format. 
.TP
.B %n
The user name (contents of \fB$USERNAME\fP).
.TP
.B %w
The date in <Mon> dd format.
.TP
.B %W
The date in mm/dd/yy format.
.TP
.B %D
The date in yy-mm-dd format.
.TP
.B %l
The line (tty) the user is logged on.
.TP
.B %#
A `#' if \fBzsh\fP is run as a root shell, a `%' if not.
.TP
.B %%
A single %.
.RE
.PD
.PP
.PD 0
.B PROMPT2
Secondary prompt string,
expanded in the
same manner as
.BR PROMPT .
.TP
.B PROMPT3
Selection prompt string
used within a
.B select
loop, by default
.RB `` "#? \|" ''.
.TP
.B SHELL
The pathname of the user's shell.
.TP
.B WATCH
A colon-separated list of users to be checked for login and logout
activity.  If set to `all', the login and logout activity
of all users will be monitored.
.TP
.B WATCHFMT
The format of the login/logout reports.
The following
sequences are available for the format specification:
.RS
.PP
.TP
.B %n
The name of the user that logged in/out.
.TP
.B %a
The observed action, i.e. "logged on" or "logged off".
.TP
.B %l
The line (tty) the user is logged on.
.TP
.BR %S\  ( %s )
Start (stop) standout mode.
.TP
.BR %B\  ( %b )
Start (stop) boldfacing mode.
.TP
.BR %U\  ( %u )
Start (stop) underline mode.
.TP
.B %M
The full hostname of the remote host.
.TP
.B %m
The hostname up to the first ".". If only 
the ip address is available or the utmp 
field contains the name of an X-windows 
display, the whole name is printed.
.TP
.B %t or %@
The time, in 12-hour, am/pm format (logout 
time is approximated if unavailable).
.TP
.B %T
The time, in 24-hour format.
.TP
.B %w
The date in <Mon> dd format.
.TP
.B %W
The date in mm/dd/yy format.
.TP
.B %D
The date in yy-mm-dd format.
.RE
.PD
.PP
If
.B WATCHFMT
is not set, the format defaults to
"%n has %a %l from %m."
.RE
.PP
\fBzsh\fP gives default values to
\fBPATH\fP, \fBPROMPT\fP, \fBPROMPT2\fP, \fBPROMPT3\fP,
and \fBIFS\fP,
while
.B SHELL
and
.B MAIL
are
not set at all by \fBzsh\fP (although
.B HOME
.I is
set by
.IR login (1)).
On some systems
.B MAIL
and
.B SHELL
are also
set by
.IR login (1)).
.B \fBzsh\fP
expands the value of
.B HOME
so that it does not contain any symbolic links.
.SS Arithmetic Substitution
An arithmetic expression of the form
.B $[...]
is replaced by the value of the arithmetic expression
within the brackets.  See
.B
Arithmetic Evaluation
below.
.SS Command Substitution
The standard output from a command of the form
.B $(...)
or
.B `...`
may be used as part or all
of a word;
trailing newlines are removed.
In the second (archaic) form, the string between the quotes is processed
for special quoting characters before the command is executed. (See
.BR Quoting ).
The command substitution
\^\fB$(\^cat\ file\^)\fP\^
can be replaced by the equivalent but faster
\^\fB$(\^<file\^)\fP\^.
.SS Brace Expansion
A string of the form
.B {str,str,...}
is expanded to each string in the comma-separated list in the
specified order.  This construct may be nested.
.PP
A five-character string of the form
.B {x\-y}
is expanded to each character in the range from x to y, inclusive.
.SS Filename Substitution
After alias substitution is performed, each word
is checked to see if it begins with an unquoted
.B \(ap 
or
.BI = .
If it begins with a
.BI \(ap ,
then the word up to a
.B /
is checked to see if it matches a user name on the system.
If a match is found, the
.B \(ap
and the matched login name is replaced by the
login directory of the matched user.
A
.B \(ap
by itself, or in front of a
.BR / ,
is replaced by \fB$HOME\fP.
A
.B \(ap
followed by a
.B +
or
.B \-
is replaced by \fB$PWD\fP and \fB$OLDPWD\fP respectively.
.PP
If the word begins with a
.B =
followed by a letter, the word
is replaced by the full pathname of the command name
following the
.BI = .
Thus
.BI = foo
is a shorthand for
\^\fB$(\^which\ \fIfoo\fB\^)\fR\^.
If the word is of the form
.B =number
or
.BR =number/... ,
then the first part of the word is replaced
by the appopriate element of the directory stack,
corresponding to the specified number.
The stack is viewed as zero-based, i.e.,
.B =0
is the same as
.BR $PWD .
As a special
case,
.B =\-
is recognized as indicating the last directory in the stack.
.PP
All of the above forms of filename substitution
may be followed by any of the modifiers allowed in the
history mechanism except \fBq\fP and \fBx\fP.
.SS Filename Generation
Following substitution, each command
.I word
is scanned for
the characters
.BR \(** ,
.BR ? ,
.BR [ ,
.BR ^ ,
.BR # ,
.BR < ,
and
.BR | .
If one of these characters appears
then the word is regarded as a
.IR pattern .
The word is replaced with alphabetically sorted filenames that match the pattern.
If no filename is found that matches the pattern, then
the word is left unchanged.
When a
.I pattern
is used for filename generation,
the character
.B .
at the start of a filename
or immediately following a
.BR /
must be matched explicitly, unless the 
.B globdots
option is set.
Also, the
.B /
character itself must be matched explicitly.
In filename generation, no pattern matches "." or "..".
In other instances of pattern matching the
.B /
and
.B .
are not treated specially.
.PP
.PD 0
.RS
.TP
.B \(**
Matches any string, including the null string.
.TP
.B ?
Matches any single character.
.TP
.BR [ \^.\|.\|.\^ ]
Matches any one of the enclosed characters.
A pair of characters separated by
.B \-
matches any
character lexically between the pair, inclusive.
If the first character following the opening "["
is a "^" then any character not enclosed is matched.
A
.B \-
can be included in the character set by putting it as the
first or last character.
.TP
.B <...>
Matches a numeric field.  A pattern of the form
.BR <x\-y> ,
where x and y are decimal integers, matches any number between
x and y inclusive.  Patterns of the form
.B <x\->
and
.B <\-y>
match any number greater than or equal to x, and less than or
equal to y, respectively.  The degenerate
.B <\->
or simply
.B <>
matches any number.  Note that a
.B <...>
pattern eats up
any numbers it encounters; thus
.B foo<1\-5>7
does not match
"foo27", even though 2 is between 1 and 5.
.TP
.B x#
Matches zero or more occurrences of the pattern x.
.TP
.B x##
Matches one or more occurrences of the pattern x.
.TP
.B ^pattern
Matches anything but the specified pattern.
.TP
.B foo|bar
Matches either foo or bar.
.PD
.RE
.PP
Parentheses may be used for grouping.  Note that the \fB|\fP character
must be within parentheses, so that the lexical analyzer does
not think it is a pipe character.  Also note that "/" has a
higher precedence than "^"; that is:
.RS
.PP
ls
.BI ^ foo / bar
.RE
.PP
will search directories in "." except "./foo" for a file named bar.
.PP
A pathname component of the form
.BI ( foo /)#
matches a path consisting of zero or more directories
matching the pattern foo.
As a shorthand,
.B ..../
is equivalent to
.BR (*/)# .
Thus:
.RS
.PP
ls
.BI (*/)# bar
.RE
.PP
or
.RS
.PP
ls
.BI ..../ bar
.RE
.PP
does a recursive directory search for files named bar.
.PP
If used for filename generation, a pattern may end in a qualifier
of the form \fB(X)\fP or \fB(^X)\fP, where \fBX\fP is a character that
specifies which filenames that otherwise match the given pattern
will be inserted in the argument list.  \fBX\fP may be any one of the
following:
.PD 0
.RS
.TP
.B /
directories
.TP
.B .
plain files
.TP
.B @
symbolic links
.TP
.B =
sockets
.TP
.B <
named pipes (FIFOs)
.TP
.B *
executable files (0100)
.TP
.B %
device files (character or block special)
.TP
.B r
readable files (0400)
.TP
.B w
writeable files (0200)
.TP
.B x
executable files (0100, same as *)
.TP
.B R
world-readable files (0004)
.TP
.B W
world-writeable files (0002)
.TP
.B X
world-executable files (0001)
.PD
.RE
.PP
Thus:
.RS
.PP
ls
.B
*(%)
.RE
.PP
lists all device files in the current directory,
and
.RS
.PP
ls
.B /tmp/foo*(^@)
.RE
.PP
lists all files beginning with the string
"foo" in /tmp, ignoring symlinks.  A "/" at the end of a pattern
is equivalent to "(/)".
.SS Quoting
Each of the
.I metacharacters
listed above (See
.I Definitions
above)
has a special meaning to \fBzsh\fP
and causes termination of a word unless quoted.
A character may be
.I quoted
(that is, made to stand for itself)
by preceding
it with a
.BR \e .
The pair
.B \enewline
is ignored.
All characters enclosed between a pair of single quote marks (\^\fB\(fm\^\(fm\fP\^),
are quoted.
A single quote cannot appear within single quotes.
Inside double quote marks
(\fB"\^"\fP),
parameter and command substitution occurs and
.B \e
quotes the characters
.BR \e ,
.BR \f(CW`\fP ,
\fB"\fP,
and
.BR $ .
Inside grave quote marks
.Pn ( `` )
.B \e
quotes the characters
.BR \e ,
` ,
and
.PP $ .
If the grave quotes occur within double quotes then
.BR \e
also quotes the character
\fB"\fP.
.PP
The special meaning of reserved words or aliases can be removed by quoting any
character of the reserved word.
The recognition of function names or builtin names listed below
cannot be altered by quoting them.
.SS Arithmetic Evaluation
An ability to perform integer arithmetic
is provided with the builtin
.BR let .
Evaluations are performed using
.I long
arithmetic.
Constants are of the form
[\fIbase\fB#\^\fR]\fIn\^\fP
where
.I base
is a decimal number between two and thirty-six
representing the arithmetic base
and
.I n
is a number in that base.
If
.I base
is omitted
then base 10 is used.
.PP
An arithmetic expression uses nearly the same syntax, precedence, and
associativity of
expressions in C.
The following operators are supported (listed in decreasing order
of precedence):
.PP
.PD 0
.RS
.TP
.B + \- ! \(ap ++ \-\-
unary plus/minus, logical NOT, complement, {pre,post}{in,de}crement
.TP
.B &
logical AND
.TP
.B ^
logical XOR
.TP
.B |
logical OR
.TP
.B * / %
multiplication, division, remainder
.TP
.B + \-
addition, subtraction
.TP
.B << >>
logical shift left, shift right
.TP
.B < > <= >=
comparison
.TP
.B == !=
equality and inequality
.TP
.B &&
boolean AND
.TP
.B || ^^
boolean OR, XOR
.TP
.B ? :
ternary operator
.TP
.B
= += \-= *= /= %= &= ^= |= <<= >>= &&= ||= ^^=
assignment
.TP
.B ,
comma operator
.PD
.RE
.PP
The operators &&, ||, &&=, and ||= are short-circuiting,
and only one of the latter two expressions in a ternary operator
is evaluated.  Note the precedence of the logical AND, OR,
and XOR operators.
.PP
Named parameters can be referenced by name within an arithmetic expression
without using the parameter substitution syntax.
.PP
An internal integer representation of a named parameter
can be specified with the
.B integer
builtin.
Arithmetic evaluation is performed on the value of each
assignment to a named parameter declared integer
in this manner.
.PP
Since many of the arithmetic operators require
quoting, an alternative form of the
.B let
command is provided.
For any command which begins with a
.BR (( ,
all the characters until a matching
.B ))
are treated as a quoted expression.
More precisely,
.BR (( .\|.\|. ))
is equivalent to
.B let
\fB"\fP\|.\|.\|.\fB"\fP.
.SS Prompting
When used interactively,
\fBzsh\fP prompts with the value of
.B PROMPT
before reading a command.
If at any time a newline is typed and further input is needed
to complete a command, then the secondary prompt
(that is, the value of
.BR PROMPT2 )
is issued.
.SS Input/Output
Before a command is executed, its input and output
may be redirected using a special notation interpreted by \fBzsh\fP.
The following may appear anywhere in a simple-command
or may precede or follow a
.I command
and are
.I not
passed on to the invoked command.
Substitution occurs before
.I word
is used except as noted below.
If the result of substitution on
.I word
produces more than one filename,
redirection occurs for each
separate filename in turn.
.TP 14
.BI < word
Use file
.I word
as standard input (file descriptor 0).
.TP
.BI > word
Use file
.I word
as standard output (file descriptor 1).
If the file does not exist then it is created.
If the file exists, and the
.B clobber
option is not set,
this causes an error;
otherwise, it is truncated to zero length.
.TP
.BI >! " word"
Same as
.BR > ,
except that the file is truncated to zero length
if it exists, even if
.B clobber
is not set.
.TP
.BI >> word
Use file
.I word
as standard output.
If the file exists then output is appended to it.
If the file does not exist, and the
.B clobber
option is not set,
this causes an error;
otherwise, the file is created.
.TP
.BI >>! " word"
Same as
.BR >> ,
except that the file is created if it does not
exist, even if
.B clobber
is not set.
.TP
.BI << word
The shell input is read up to a line that is the same as
.IR word ,
or to an end-of-file.
No parameter substitution, command substitution or
filename generation is performed on
.IR word .
The resulting document,
called a
.IR here-document ,
becomes
the standard input.
No interpretation
is placed upon the characters of the document.
.TP
.BI <& digit
The standard input is duplicated from file descriptor
.I digit
(see
.IR dup (2)).
Similarly for the standard output using
.BR >&
.IR digit .
.TP
.BI >& word
Same as
.BI > word
.B 2>&1 .
.TP
.BI >>& word
Same as
.BI >> word
.B 2>&1 .
.TP
.B <&\-
The standard input is closed.
Similarly for the standard output using
.BR >&\- .
.TP
.BI <&! " digit"
Same as
.B <&\-
.BI <& digit .
.TP
.BI >&! " digit"
Same as
.B >&\-
.BI >& digit .
.TP
.B <&p
The input from the coprocess is moved to standard input.
.TP
.B >&p
The output to the coprocess is moved to standard output.
.PP
If one of the above is preceded by a digit,
then the
file descriptor number referred to is that specified
by the digit
(instead of the default 0 or 1).
For example:
.RS
.PP
\&.\|.\|. \|2>&1
.RE
.PP
means file descriptor 2 is to be opened
for writing as a duplicate
of file descriptor 1.
.PP
The order in which redirections are specified is significant.
\fBzsh\fP evaluates each redirection in terms of the
.RI ( "file descriptor" ", " file )
association at the time of evaluation.
For example:
.RS
.PP
\&.\|.\|. \|1>\fIfname\^\fP 2>&1
.RE
.PP
first associates file descriptor 1 with file
.IR fname .
It then associates file descriptor 2 with the file associated with file
descriptor 1 (that is,
.IR fname ).
If the order of redirections were reversed, file descriptor 2 would be associated
with the terminal (assuming file descriptor 1 had been) and then file descriptor
1 would be associated with file
.IR fname .
.PP
If the user tries to open a file descriptor for writing more than once,
\fBzsh\fP opens the file descriptor as a pipe to a process that copies
its input to all the specified outputs, similar to tee(1).  Thus:
.RS
.PP
.B date >foo >bar
.RE
.PP
writes the date to two files, named "foo" and "bar".
Note that a pipe is an implicit indirection; thus
.RS
.PP
.B date >foo | cat
.RE
.PP
writes the date to the file "foo", and also pipes it to cat.
.PP
If the user tries to open a file descritor for reading more than once,
\fBzsh\fP opens the file descriptor as a pipe to a process that copies
all the specified inputs to its output in the order
specified, similar to cat(1).  Thus
.RS
.PP
.B sort <foo <fubar
.RE
.PP
or even
.RS
.PP
.B sort <f{oo,ubar}
.RE
.PP
is equivalent to "cat foo bar | sort".  Note that
a pipe is in implicit indirection; thus
.RS
.PP
.B cat bar | sort <foo
.RE
.PP
is equivalent to "cat bar foo | sort" (note the order of the inputs).
.PP
If a simple command consists of one or more redirection operators
and zero or more parameter assignments, but no command name,
the command \fBcat\fP is assumed.  Thus
.RS
.PP
.B < file
.RE
.PP
prints the contents of \fBfile\fP.
.PP
If a command is followed by
.B &
and job control is not active,
then the default standard input
for the command
is the empty file
.BR /dev/null .
Otherwise, the environment for the execution of a command contains the
file descriptors of the invoking shell as modified by
input/output specifications.
.SS Environment
The
.I environment
(see
.IR environ (7))
is a list of name-value pairs that is passed to
an executed program in the same way as a normal argument list.
The names must be
.I identifiers
and the values are character strings.
\fBzsh\fP interacts with the environment in several ways.
On invocation, \fBzsh\fP scans the environment
and creates a
parameter
for each name found,
giving it the corresponding value and marking it exported.
Executed commands inherit the environment.
If the user modifies the values of these
parameters
or creates new ones,
using the
.B export
command they become part of the
environment.
The environment seen by any executed command is thus composed
of any name-value pairs originally inherited by \fBzsh\fP,
whose values may be modified by the current shell,
plus any additions
which must be noted in
.B export
commands.
.PP
The environment for any
.I simple-command
or function
may be augmented by prefixing it with one or more parameter assignments.
A parameter assignment argument is a word of the form
.IR identifier=value .
Thus:
.RS
.PP
TERM=450 \|cmd \|args				and
.br
(export \|TERM; \|TERM=450; \|cmd \|args)
.RE
.PP
are equivalent (as far as the above execution of
.I cmd
is concerned).
.PP
If the
.B keyword
flag is set,
.I all
parameter assignment arguments are placed in the environment,
even if they occur after the command name.
.SS Function
.PP
The
.B function
reserved word, described in the
.I Commands
section above,
is used to define shell functions.
Shell functions are read in and stored internally.
Alias names are resolved when the function is read.
Functions are executed like commands with the arguments
passed as positional parameters.
(See
.I Execution
below).
.PP
Functions execute in the same process as the caller and
share all files
and present working directory with the
caller.
A trap on
.B EXIT
set inside a function
is executed after the function completes in the environment
of the caller.
.PP
The builtin
.B return
is used to return
from function calls.
Errors within functions return control to the caller.
.PP
Function identifiers
can be listed with the
.B function
builtin.
Functions can be undefined with the
.B unfunction
builtin.
.PP
The following functions, if defined, have special meaning to \fBzsh\fP:
.PP
.PD 0
.RS
.TP
\fBchpwd\fP
Executed whenever the current working directory is changed.
.TP
\fBprecmd\fP
Executed before each prompt.
.TP
\fBperiodic\fP
If the parameter
.B PERIOD
is set, this function is executed every
.B PERIOD
minutes, just before a prompt.
.TP
\fBTRAPxxx\fP
If defined and non-null,
this function will be executed whenever \fBzsh\fP 
catches a signal \fBSIGxxx\fP, where \fBxxx\fP is a signal
name as specified for the \fBkill\fP builtin (see below).
In addition, \fBTRAPERR\fP is executed whenever a command has a non-zero
exit status, \fBTRAPDEBUG\fP is executed after each command, and
\fBTRAPEXIT\fP
is executed when \fBzsh\fP exits,
or when the current function exits if defined
inside a function.
If a function of this form is defined and null,
\fBzsh\fP and processes spawned by it will ignore \fBSIGxxx\fP.
.PD
.RE
.SS Jobs
.PP
If the
.B monitor
option of the
.B set
command is turned on,
an interactive shell associates a \fIjob\fR with each pipeline.
It keeps
a table of current jobs, printed by the
.B jobs
command, and assigns them small integer numbers.
When a job is started asynchronously with
.BR & ,
\fBzsh\fP prints a line which looks
like:
.PP
.DT
	[1] 1234
.PP
indicating that the job which was started asynchronously was job number
1 and had one (top-level) process, whose process id was 1234.
.PP
If you are running a job and wish to do something else you may hit the key
\fB^Z\fR (control-Z) which sends a STOP signal to the current job.
\fBzsh\fP will then normally indicate that the job has been `suspended',
and print another prompt.
You can then manipulate the state of this job,
putting it in the background with the
.B bg
command, or run some other
commands and then eventually bring the job back into the foreground with
the foreground command
.BR fg .
A \fB^Z\fR takes effect immediately and
is like an interrupt in that pending output and unread input are discarded
when it is typed.
.PP
A job being run in the background will suspend if it tries to read
from the terminal.
Background jobs are normally allowed to produce output,
but this can be disabled by giving the command ``stty tostop''.
If you set this
tty option, then background jobs will suspend when they try to produce
output like they do when they try to read input.
.PP
There are several ways to refer to jobs in \fBzsh\fP.
A job can be referred to by the process id of any process of the job
or by one of the following:
.PD 0
.TP
.BI % number
The job with the given number.
.TP
.BI % string
Any job whose command line begins with
.IR string .
.TP
.BI %? string
Any job whose command line contains
.IR string .
.TP
.BI %%
Current job.
.TP
.BI %+
Equivalent to
.BR %% .
.TP
.BI %\-
Previous job.
.PD
.PP
\fBzsh\fP learns immediately whenever a process changes state.
It normally informs you whenever a job becomes blocked so that
no further progress is possible.  If
.B notify
is not set, it waits until
just before it prints
a prompt before it informs you.
.PP
When the monitor mode is on, each background job that completes
triggers any trap set for
.BR CHLD .
.PP
When you try to leave \fBzsh\fP while jobs are running or suspended, you will
be warned that `You have suspended (running) jobs.'
You may use the
.B jobs
command to see what they are.
If you do this or immediately try to
exit again, \fBzsh\fP will not warn you a second time; the suspended
jobs will be terminated, and the running jobs will be sent
a \fBSIGHUP\fP signal.
To avoid having \fBzsh\fP terminate the running jobs, either
use the \fBnohup\fP(1) command or the \fBdisown\fP builtin (see below).
.SS Signals
The INT and QUIT signals for an invoked
command are ignored if the command is followed by
.B &
and job
.B monitor
option is not active.
Otherwise, signals have the values
inherited by \fBzsh\fP from its parent
(but see the \fBTRAPxxx\fP special function above).
.SS Execution
Each time a command is executed, the above substitutions
are carried out.
If the command name matches one
of the
.I builtins
listed below,
it is executed within the
current shell process.
Next, the command name is checked to see if
it matches one of the user defined functions.
If it does,
the positional parameters are saved
and then reset to the arguments of the
.I function
call.
When the
.I function
completes or issues a
.BR return ,
the positional parameter list is restored
and any trap set on
.B EXIT
within the function is executed.
The value of a
.I function
is the value of the last command executed.
A function is also executed in the
current shell process.
If a command name is not a
.I builtin
or a user defined
.IR function ,
a process is created and
an attempt is made to execute the command via
.IR exec (2).
.PP
The shell parameter
.B PATH
defines the search path for
the directory containing the command.
Alternative directory names are separated by
a colon.
The default path is
.B /bin:/usr/bin:
(specifying
.BR /bin ,
.BR /usr/bin ,
and the current directory
in that order).
The current directory can be specified by
two or more adjacent colons, or by a colon
at the beginning or end of the path list.
If the command name contains a \fB/\fP then the search path
is not used.
Otherwise, each directory in the path is
searched for an executable file.
.PP
Whenever \fBzsh\fP executes an external command, it gives
control of the tty to the command.  If the command
completes with a zero return code, \fBzsh\fP does not reset
the tty; otherwise, the tty modes are reset to what they were
before the command was executed.  If a process is suspended,
\fBzsh\fP saves the state of the tty and resets the tty modes;
if the process is later restarted, the tty modes are restored
to what they were when the process was suspended.
.SS Command Re-entry.
The text of the last
.B HISTSIZE
(default 128)
commands entered from a terminal device
is saved in memory.
The builtin
.B fc
is used to list or
edit a portion of this file.
The portion of the file to be edited or listed can be selected by
number or by giving the first character or
characters of the command.
A single command or range of commands can be specified.
If you do not specify an editor program as
an argument to
.B fc
then the value of the parameter
.B FCEDIT
is used.
If
.B FCEDIT
is not defined then
.B /usr/ucb/vi
is used.
The edited command(s) is printed and re-executed upon
leaving the editor.
The editor name
.B \-
is used to skip the editing phase and
to re-execute the command.
In this case a substitution parameter of the form
\fIold\fP\fB=\fP\fInew\fP
can be used to modify the command before execution.
For example, if
.B r
is aliased to
.B \(fmfc \-e \-\(fm
then typing
`\fBr bad=good c\fP'
will re-execute the most recent command which starts with the letter
.BR c ,
replacing the first occurrence of the string
.B bad
with the string
.BR good .
.SS Readline
This is the library that handles reading input when using an interactive
shell.
By default, the line editing commands
are similar to those of Emacs.
A vi-style line editing interface is also available.
.PP
In this section, the Emacs\-style notation is used to denote
keystrokes.  Control keys are denoted by C\-\fIkey\fR, e.g. C\-n
means Control\-N.  Similarly, 
.I meta
keys are denoted by M\-\fIkey\fR, so M\-x means Meta\-X.  (On keyboards
without a 
.I meta
key, M\-\fIx\fP means ESC \fIx\fP, i.e. press the Escape key
then the
.I x
key.
The combination M\-C\-\fIx\fP means ESC\-Control\-\fIx\fP,
or press the Escape key
then hold the Control key while pressing the
.I x
key.)
.PP
You may change the default key\-bindings with an
.B \(ap/.inputrc 
file.  Other 
programs that use this library may add their own commands and bindings.
.PP
For example, if you wanted to make M\-C\-u execute the command
.IR universal\-argument ,
then 
in your
.B \(ap/.inputrc
file you would put:
.RS
.PP
M\-Control\-u: universal\-argument
.RE
or
.RS
C\-Meta\-u: universal\-argument
.RE
.PP
You can use the following names for characters: RUBOUT, DEL, ESC,
NEWLINE, SPACE, RETURN, LFD, TAB.
.PP
You can start with a vi-like editing mode by placing
.RS
.PP
set editing-mode vi
.RE
.PP
in your 
.B \(ap/.inputrc
file.
.PP
You can have readline use a single line for display, scrolling the input
between the two borders by placing
.RS
.PP
set horizontal\-scroll\-mode On
.RE
.PP
in your 
.B \(ap/.inputrc
file.
.PP
The following is a list of the names of the commands and the default
key-strokes to get them.
.SS Commands for Moving
.PP
.PD 0
.TP
.B beginning\-of\-line (C\-a)
Move to the start of the current line.
.TP
.B end\-of\-line (C\-e)
Move to the end of the line.
.TP
.B forward\-char (C\-f)
Move forward a character.
.TP
.B backward\-char (C\-b)
Move back a character.
.TP
.B forward\-word (M\-f)
Move forward to the end of the next word.
.TP
.B backward\-word (M\-b)
Move back to the start of this, or the previous, word.
.TP
.B clear\-screen (C\-l)
Clear the screen leaving the current line at the top of the screen.
.PD
.SS Commands for Manipulating the History
.PP
.PD 0
.TP
.B accept\-line (Newline, Return)
Accept the line regardless of where the cursor is.
.TP
.B previous\-history (C\-p)
Fetch the previous command from the history list, moving back in
the list.
.TP
.B next\-history (C\-n)
Fetch the next command from the history list, moving forward in the
list.
.TP
.B beginning\-of\-history (M\-<)
Move to the first line in the history, the first line entered.
.TP
.B end\-of\-history (M\->)
Move to the end of the input history, i.e., the line you are entering.
.PD
.SS Commands for Changing Text
.PP
.PD 0
.TP
.B delete\-char (C\-d)
Delete the character under the cursor.  If the cursor is at the
beginning of the line, and there are no characters in the line, and
the last character typed was not C\-d, then return EOF.
.TP
.B backward\-delete\-char (Rubout)
Delete the character behind the cursor.  A numeric arg says to kill
the characters instead of deleting them.
.TP
.B quoted\-insert (C\-q, C\-v)
Add the next character that you type to the line verbatim.  This is
how to insert characters like C\-q, for example.
.TP
.B self\-insert (a,\ b,\ A,\ 1,\ !,\ ...)
Insert the character typed.
.TP
.B transpose\-chars (C\-t)
Drag the character before point forward over the character at point.
Point moves forward as well.  If point is at the end of the line, then
transpose the two characters before point.  Negative arguments don't work.
.TP
.B transpose\-words (M\-t)
Drag the word behind the cursor past the word in front of the cursor
moving the cursor over that word as well.
.TP
.B upcase\-word (M\-u)
Uppercase the current (or following) word.  With a negative argument,
do the previous word, but do not move point.
.TP
.B downcase\-word (M\-l)
Lowercase the current (or following) word.  With a negative argument,
do the previous word, but do not move point.
.TP
.B capitalize\-word (M\-c)
Capitalize the current (or following) word.  With a negative argument,
do the previous word, but do not move point.
.PD
.SS Killing and Yanking
.PP
.PD 0
.TP
.B kill\-line (C\-k)
Kill the text from the current cursor position to the end of the line.
This saves the killed text on the kill\-ring.  (see below)
.TP
.B backward\-kill\-line
Kill backward to the beginning of the line.  This is normally unbound,
in favor of \fBunix-line-discard\fP, which emulates the behavior of
the standard Unix terminal driver.
.TP
.B kill\-word  (M\-d)
Kill from the cursor to the end of the current word, or if between
words, to the end of the next word.
.TP
.B backward\-kill\-word (M\-Rubout)
Kill the word behind the cursor.
.TP
.B unix\-line\-discard (C\-u)
Do what C\-u used to do in Unix line input.  We save the killed text on
the kill\-ring, though.
.TP
.B unix\-word\-rubout (C\-w)
Do what C\-w used to do in Unix line input.  The killed text is saved
on the kill\-ring.  This is different than backward\-kill\-word because
the word boundaries differ.
.TP
.B yank (C\-y)
Yank the top of the kill ring into the buffer at point.
.TP
.B yank\-pop (M\-y)
Rotate the kill\-ring, and yank the new top.  Only works following
`yank' or `yank\-pop'.
.PD
.SS Arguments
.PP
.PD 0
.TP
.B digit\-argument (M\-0, M\-1, ..., M\-\-)
Add this digit to the argument already accumulating, or start a new
argument.  M\-\- starts a negative argument.
.TP
.B universal\-argument
Do what C\-u does in 
.I Emacs.
By default, this is not bound to a key.
.PD
.SS Completing
.PP
.PD 0
.TP
.B complete (TAB)
Perform substitution on the text before point.
If no substitutions can be performed, attempt
filename completion.
If the text before point is a tilde followed by
a word which is a prefix of one of the usernames
in
.BR \(ap/.zfriends ,
substitute the text with the
home directory of that user.
.TP
.B possible\-completions (M-?)
List the possible completions of the text before point.
.PD
.SS Miscellaneous
.PP
.PD 0
.TP
.B abort (C\-g)
Abort the current editing command and
ring the terminal's bell.
.TP
.B do\-uppercase\-version (M\-a, M\-b, ...)
Run the command that is bound to the uppercased key.
.TP
.B prefix\-meta (ESC)
Metafy the next character typed.  This is for
people without a meta key.  ESC f is equivalent to Meta\-f.
.TP
.B undo (C\-_)
Incremental undo, separately remembered for each line.
.TP
.B revert\-line (M\-r)
Undo all changes made to this line.  This is like typing the `undo'
command enough times to get back to the beginning.
.TP
.B history\-expand (M\-Space)
Perform history expansion on this line.
.TP
.B check\-spelling (M\-$)
Check the spelling of the word before the point.
.PD
.SS Builtins
The following simple-commands are executed in the shell process.
Input/Output redirection is permitted.
Unless otherwise indicated, the output is written on file descriptor 1
and the exit status, when there is no syntax error, is zero.
.PD
.TP
\fB:\fP [ \fIarg\^\fP .\|.\|. ]
The command only expands parameters.
.br
.ne 2
.TP
\fB\|. \fIfile\fP
Read commands from
.IR file .
The commands are executed in the current shell environment.
The exit status is the exit status of the last command executed.
.TP
\fBalias\fP [ \fB\-a\fP ]  [ \fIname\fP [ \fIstr\^\fP .\|.\|. ] ]
.B alias
with no arguments prints the list of aliases
on standard output.
If
.I name
is supplied with no
.IR str ,
the alias associated with
.I name
is printed.
Otherwise
.I name
is defined as an alias having the specified value.
A trailing space in the value
causes the next word to be checked for
alias substitution.
Unless the
.B \-a
flag is used, the alias will only be substituted with its value
if it appears as a command word.
.TP
.PD 0
\fBbg\fP [ \fIjob\fP ]
.TP
\fIjob\fP \fB&\fP
.PD
Puts the specified
.I job
into the background.
The current job is put in the background
if
.I job
is not specified.
See
.I Jobs
for a description of the format of
.IR job .
.TP
\fBbreak\fP [ \fIn\^\fP ]
Exit from the enclosing
.BR for
.BR while
.BR until
or
.B select
loop, if any.
If
.I n
is specified then break
.I n
levels.
.TP
\fBcontinue\fP [ \fIn\^\fP ]
Resume the next iteration of the enclosing
.BR for
.BR while
.BR until
or
.B select
loop.
If
.I n
is specified then resume at the
.IR n -th
enclosing loop.
.TP
.PD 0
\fBcd\fP [ \fIarg\^\fP ]
.TP
\fBcd\fP \fIold\^\fP \fInew\^\fP
.PD
This command can be in either of two forms.
In the first form it
changes the current directory to
.IR arg .
If
.I arg
is
.B \-
the directory is changed to the previous
directory.
The shell
parameter
.B HOME
is the default
.IR arg .
The parameter
.B PWD
is set to the current directory.
The shell parameter
.B CDPATH
defines the search path for
the directory containing
.IR arg .
Alternative directory names are separated by
a colon.
The default path is
the current directory.
If
.I arg
begins with a \fB/\fP then the search path
is not used.
Otherwise, each directory in the path is
searched for
.IR arg .
.IP
The second form of
.B cd
substitutes the string
.I new
for the string
.I old
in the current directory name,
.B PWD
and tries to change to this new directory.
.TP
\fBdirs\fP [ \fIdirs\fP .\|.\|. ]
If no \fIdirs\fP are specified, prints the directory stack.
Otherwise loads the directory stack with the arguments,
which must be directory names, and puts \fB$PWD\fP at the top
of the stack.
.TP
\fBdisown\fP [ \fIjob\fP .\|.\|. ]
The specified jobs are removed from the job table.
This means that the status of these jobs will no longer
be monitored, and the user can exit safely from an interactive
shell without sending a \fBSIGHUP\fP to these jobs.
.TP
\fBecho\fP [ \fB\-n\fP ] [ \fIarg\^\fP .\|.\|. ]
Echos the arguments to the standard output.  Prints
a final newline if the \fB\-n\fP flag is not specified.
.TP
\fBeval\fP [ \fIarg\^\fP .\|.\|. ]
The arguments are read as input
to the shell
and the resulting command(s) executed.
.TP
\fBexit\fP [ \fIn\^\fP ]
Causes the shell to exit
with the exit status specified by
.IR n .
If
.I n
is omitted then the exit status is that of the last command executed.
An end-of-file will also cause the shell to exit
except for a
shell which has the
.I ignoreeof
option (See
.B setopt
below) turned on.
.TP
\fBexport\fP [ \fIname\fP[\fB=\fP\fIvalue\^\fP] ] .\|.\|.
The given
.IR name s
are marked for automatic
export to the
.I environment
of subsequently-executed commands.
.TP
.PD 0
\fBfc\fP [ \fB\-e\fP \fIename\^\fP \ ] [ \fB\-nlr\^\fP ] [ \fIold=new\fP .\|.\|. ] [ \fIfirst\^\fP [ \fIlast\^\fP ] ]
.PD
A range of commands from
.I first
to
.I last
is selected from the last
.B HISTSIZE
commands that were typed at the terminal.
The arguments
.I first
and
.I last
may be specified as a number or as a string.
A string is used to locate the most recent command starting with
the given string.
A negative number is used as an offset to the current command number.
Any number of substitutions
.I old=new
are performed.
If the flag
.BR \-l ,
is selected,
the commands are listed on standard output.
Otherwise, the editor program
.I ename
is invoked on a file containing these
keyboard commands.
If
.I ename
is not supplied, then the value of the parameter
.B FCEDIT
(default /usr/ucb/vi)
is used as the editor.
If
.I ename
is `\-', no editor is invoked.
When editing is complete, the edited command(s)
are executed.
If
.I last
is not specified
then it will be set to
.IR first .
If
.I first
is not specified
the default is the previous command
for editing and \-16 for listing.
The flag
.B \-r
reverses the order of the commands and
the flag
.B \-n
suppresses command numbers when listing.
.TP
.PD 0
\fBfg\fP [ \fIjob\fP ]
.TP
\fIjob\fP
.PD
The
specified
.I job
is brought to the foreground.
Otherwise, the current job is
brought into the foreground.
See
.I Jobs
for a description of the format of
.IR job .
.TP
\fBglob\fP \fIname\fP .\|.\|.
Marks \fIname\fP, which must be a command name,
for normal filename generation.
See \fBnoglob\fP below.
.TP
\fBhash\fP \fIname\fP \fIfile\fP
Adds an entry to the command hash table corresponding
to \fIname\fP.  \fIfile\fP is an executable file to be run
whenever \fIname\fP is specified in a simple command.
.TP
\fBinteger\fP \fIname\fP .\|.\|.
The specified named parameters are marked for an internal
integer representation.
.TP
\fBjobs\fP [ \fB\-lp\^\fP ] [ \fIjob\^\fP .\|.\|. ]
Lists information about each given job; or all active jobs if
.I job
is omitted.
The
.B \-l
flag lists process ids in addition to the normal information.
The
.B \-p
flag causes only the process group to be listed.
See
.I Jobs
for a description of the format of
.IR job .
.TP
.PD 0
\fBkill\fP [ \fB\-\fP\fIsig\^\fP ] \fIjob\^\fP .\|.\|.
.TP
\fBkill\fP \fB\-l\fP
.PD
Sends either the TERM (terminate) signal or the
specified signal to the specified jobs or processes.
Signals are either given by number or by names (as given in
.BR /usr/include/signal.h ,
stripped of the prefix ``SIG'').
If the job is suspended, it will be send a CONT (continue) signal
after the specified signal is delivered.
The argument
.I job
can the process id of a process that is not a member of one of the
active jobs.
See
.I Jobs
for a description of the format of
.IR job .
In the second form,
.BR "kill \-l" ,
the signal numbers and names are listed.
.TP
\fBlet\fP \fIarg\^\fP .\|.\|.
Each
.I arg
is a separate
.IR "arithmetic expression"
to be evaluated.
See
.I "Arithmetic Evaluation"
above, for a description of arithmetic expression evaluation.
The exit status is
0 if the value of the last expression
is non-zero, and 1 otherwise.
.TP
\fBlimit\fP [ \fB\-h\fP ] [ \fIresource\fP [ \fImax-use\fP ] ]
.PD 0
.TP
.B "limit \-s"
.PD
.br
Limit the consumption by any process the shell spawns,
each not to exceed
.I max-use
on the specified
.IR resource .
If
.I max-use
is omitted, print the current limit; if
.I resource
is omitted, display all limits.
.RS
.TP
.B \-h
Use hard limits instead of the current limits.  Hard limits impose a
ceiling on the values of the current limits.  Only the super-user may
raise the hard limits.
.LP
.I resource
is one of:
.RS
.TP 15
.B cputime
Maximum
.B CPU
seconds per process.
.PD 0
.TP
.B filesize
Largest single file allowed.
.TP
.B datasize
Maximum data size (including stack) for the process.
.TP
.B stacksize
Maximum stack size for the process.
.TP
.B coredumpsize
Maximum size of a core dump (file).
.TP
.B descriptors
Maximum value for a file descriptor.
.PD
.RE
.LP
.I max-use
is a number, with an optional scaling factor, as follows:
.RS
.TP 15
.IB n h
Hours (for
.BR cputime ).
.PD 0
.TP
.IB n k
.I n
kilobytes. 
This is the default for all but
.BR cputime .
.TP
.IB n m
.I n
megabytes or minutes (for
.BR cputime ).
.TP
.IB mm : ss
Minutes and seconds (for
.BR cputime ).
.PD
.RE
.RE
.IP
If
.B limit
is invoked solely with the
.B s
option, the current limits are taken to apply
to the parent shell as well as to all processes
spawned by it.
.TP
.B log
Inform the user of all users
affected by
.B WATCH
whether they have been announced before or not.
.TP
\fBmostglob\fP \fIname\fP .\|.\|.
Marks \fIname\fP, which must be a command name,
for modified filename generation.  Whenever \fIname\fP
is used as a command name in a simple command,
filename generation is not performed on the first argument
following the command name.
If there are one or more initial arguments beginning with a
dash (corresponding to option arguments), they and the
first argument following them
are not subject to filename generation.
.TP
\fBnoglob\fP \fIname\fP .\|.\|.
Marks \fIname\fP, which must be a command name,
for no filename generation.  Whenever \fIname\fP
is used as a command name in a simple command,
filename generation is not performed on its arguments.
.TP
.B popd [ \fB+\fIn\fP ]
Pop the directory stack, and
.BR cd s
to the new top directory.
The elements of the directory stack are numbered from 0 starting at the top.
.RS
.TP 8
.BI + n
Discard the
.IR n 'th
entry in the stack.
.RE
.HP
.B pushd
.RB [ +\c
.IR n " |"
.IR dir ]
.br
Push a directory onto the directory stack.
With no arguments, exchange the top two elements,
unless the option
.B pushdtohome
is set, in which case push the current directory
onto the stack and change to \fB$HOME\fP.
.RS
.TP
.BI + n
Rotate the
.IR n 'th
entry to the top of the stack and
.B cd
to it.  If the option
.B dextract
is set, extract the
.IR n 'th
entry from the directory stack
and
.B cd
to it.
.PD 0
.TP
.I dir
Push the current working directory onto the stack and change to
.IR dir .
.PD
.RE
.TP
\fBpwd\fP
Equivalent to
\fBecho $PWD\fP.
.TP
\fBread\fP [ \fIname\fB?\fIprompt\^\fR ] [ \fIname\^\fP .\|.\|. ]
The shell input mechanism.
One line is read and
is broken up into fields using the characters in
.B IFS
as separators.
If
.IR name
is omitted then
.B REPLY
is used as the default
.IR name.
The exit status is 0 unless an end-of-file is encountered.
If the first argument contains a
.BR ? ,
the remainder of this word is used as a
.I prompt
on standard error
when the shell is interactive.
The exit status is 0 unless an end-of-file is encountered.
.TP
\fBrehash\fP
Rebuilds the command hash table.  This command is executed
automatically whenever the value of \fB$PATH\fP is changed.
.TP
\fBreturn\fP [ \fIn\^\fP ]
Causes a shell
.I function
to return
to the invoking script
with the return status specified by
.IR n .
If
.I n
is omitted then the return status is that of the last command executed.
If
.B return
is invoked while not in a
.I function
or a
\fB\|.\fP
script,
then it is the same as an
.BR exit .
.TP
\fBsched\fP [+]hh:mm \fIcommand\fP
Schedule a command for execution at a later time.
.TP
\fBset\fP [ \fIarg\fP .\|.\|. ]
Assign the arguments to the positional parameters, in order.
If no arguments are given, then the names and values of
all named parameters are printed on the standard output.
.TP
\fBsetopt\fP [ \fB\(+-aefikmnsuvxABCDEFGHIJK1234567890\fP ] \
[ \fIopt\fP .\|.\|. ]
Sets the options by letter or by name.  If no options
are specified, the current option settings are printed.
Valid options are as follows:
.RS
.PD 0
.TP 8
.B allexport (\-a)
All subsequent parameters that are defined are automatically exported.
.TP 8
.B errexit (\-e)
If a command has a non-zero exit status,
execute the
.B ERR
trap, if set,
and exit.
.TP 8
.B norcs (\-f)
\fBzsh\fP will not read the .zshrc, .zlogin, or .zlogout files.
.TP 8
.B keyword (\-k)
All parameter assigment arguments are placed in the environment
for a command, not just those that precede the command name.
.TP 8
.B interactive (\-i)
This is an interactive shell.
.TP 8
.B monitor (\-m)
Background jobs will run in a separate process group
and a line will print upon completion.
The exit status of background jobs is reported in a completion message.
This flag is turned on automatically for
interactive shells.
.TP 8
.B noexec (\-n)
Read commands and check them for syntax errors, but do not execute them.
.TP 8
.B \-t
Exit after reading and executing one command.
.TP 8
.B shinstdin (\-s)
Read commands from the standard input rather than from a file.
.TP 8
.B nounset (\-u)
Treat unset parameters as an error when substituting.
.TP 8
.B verbose (\-v)
Print shell input lines as they are read.
.TP 8
.B xtrace (\-x)
Print commands and their arguments as they are executed.
.TP 8
.B clobber (\-1)
Permits \fB>\fP redirection to truncate existing files.
Also allows \fB>>\fP redirection to create files.
.TP 8
.B nobadpattern (\-2)
In filename generation, do not report an error
when given a malformed pattern.
Instead, pass the pattern unchanged
as an argument.
.TP 8
.B nonomatch (\-3)
In filename generation,
do not report an error when pattern matches no filenames.
Instead, pass the pattern unchanged
as an argument.
.TP 8
.B globdots (\-4)
In filename generation, do not require that an initial \fB.\fP
be matched explicitly.
.TP 8
.B notify (\-5)
Notify the user immediately when jobs are completed, rather
than wait until just before issuing a prompt.  This is
the default mode.
.TP 8
.B bgnice (\-6)
All background jobs are run at a lower priority.  This is the
default mode.
.TP 8
.B ignoreeof (\-7)
The shell will not exit on end-of-file.  Either
\fBexit\fP or \fBlogout\fP must be used.
.TP 8
.B markdirs (\-8)
All directory names resulting from filename generation
have a trailing / appended.
.TP 8
.B autolist (\-9)
List possilities on an ambiguous completion.
.TP 8
.B correct (\-0)
Automatically try to correct the spelling of commands.
.TP 8
.B dextract (\-A)
See \fBpushd\fP above.
.TP 8
.B nobeep (\-B)
Prevent the shell from beeping.
.TP 8
.B printexitvalue (\-C)
If an interactive program exits non-zero, print the
exit value.
.TP 8
.B pushdtohome (\-D)
Make pushd with no arguments do the equivalent
of \fBpushd \(ap\fP, like \fBcd\fP.
.TP 8
.B pushdsilent (\-E)
Prevent \fBpushd\fP and \fBpopd\fP from printing
the directory stack.
.TP 8
.B nullglob (\-G)
If a pattern for filename generation does not match any
filenames, delete it from the argument list rather than
report an error.
.TP 8
.B rmstarsilent (\-H)
Do not prompt the user before execution of `rm *'.
.TP 8
.B ignorebraces (\-I)
Do not perform brace expansion.
.TP 8
.B cdablevars (\-J)
If a named parameter (without the \fB$\fP) is specified
to the \fBcd\fP, \fBpushd\fP, or \fBpopd\fP commands,
and the value of the named parameter begins with a `/',
\fBzsh\fP will act as if the \fB$\fP had been supplied.
.TP 8
.B nobanghist (\-K)
Do not perform `\fB!\fP' history substitution;
do not treat the `\fB!\fP' character
specially.
.RE
.PD
.TP
\fBshift\fP [ \fIn\^\fP ]
.br
The positional parameters from
\fB$\fP\fIn\fP\fB+1\fP
\&.\|.\|.
are renamed
.B $1
\&.\|.\|.\^
, default
.I n
is 1.
.PD
.PP
.PD 0
\fBtest\fP \fIexpr\fP
.TP
\fB[\fP \fIexpr\fP \fB]\fP
Return a status of 0 (true) or 1 (false) depending on
the evaluation of
the conditional expression
.IR expr .
Expressions may be unary or binary.  Unary
expressions are often used to examine the status of a file.  There
are string operators
and numeric comparison operators as well.
.RS
.PD 0
.TP
.B \-b \fIfile\fP
True if \fIfile\fP exists and is block special.
.TP
.B \-c \fIfile\fP
True if \fIfile\fP exists and is character special.
.TP
.B \-d \fIfile\fP
True if \fIfile\fP exists and is a directory.
.TP
.B \-f \fIfile\fP
True if \fIfile\fP exists and is a regular file.
.TP
.B \-g \fIfile\fP
True if \fIfile\fP exists and is set-group-id.
.TP
.B \-k \fIfile\fP
True if \fIfile\fP has its ``sticky'' bit set.
.TP
.B \-L \fIfile\fP
True if \fIfile\fP exists and is a symbolic link.
.TP
.B \-p \fIfile\fP
True if \fIfile\fP exists and is a named pipe.
.TP
.B \-r \fIfile\fP
True if file exists and is readable.
.TP
.B \-s \fIfile\fP
True if \fIfile\fP exists and has a non-zero size.
.TP
.B \-S \fIfile\fP
True if \fIfile\fP exists and is a socket.
.TP
.B \-t [\fIfd\fP]
True if
.I fd
is opened on a terminal.  If
.I fd
is omitted, it defaults to 1 (standard output).
.TP
.B \-u \fIfile\fP
True if the \fIfile\fP exists and its set-user-id bit is set.
.TP
.B \-w \fIfile\fP
True if the \fIfile\fP exists and is writable.
.TP
.B \-x \fIfile\fP
True if the \fIfile\fP exists and is executable.
.TP
.B \-O \fIfile\fP
True if the \fIfile\fP exists and is owned by the effective user id.
.TP
.B \-G \fIfile\fP
True if the \fIfile\fP exists and is owned by the effective group id.
.TP
\fIfile1\fP \-\fBnt\fP \fIfile2\fP
True if \fIfile1\fP is newer (according to
modification date) than \fIfile2\fP.
.TP
\fIfile1\fP \-\fBot\fP \fIfile2\fP
True if \fIfile1\fP is older than file2.
.TP
\fIfile1\fP \fB\-ef\fP \fIfile\fP
True if \fIfile1\fP and \fIfile2\fP have the same device and
inode numbers.
.TP
.B \-z \fIstring\fP
True if the length of \fIstring\fP is zero.
.TP
.B \-n \fIstring\fP
.TP
\fIstring\fP
True if the length of
.I string
is non-zero.
.TP
\fIstring1\fP \fB=\fP \fIstring2\fP
True if the strings are equal.
.TP
\fIstring1\fP \fB!=\fP \fIstring2\fP
True if the strings are not equal.
.TP
.B ! \fIexpr\fP
True if
.I expr
is false.
.TP
\fIexpr1\fP \-\fBa\fP \fIexpr2\fP
True if both
.I expr1
AND
.I expr2
are true.
.TP
\fIexpr1\fP \-\fBo\fP \fIexpr2\fP
True if either
.I expr1
OR
.I expr2
is true.
.TP
.I arg1 \fBOP\fP arg2
OP is one of
.BR \-eq ,
.BR \-ne ,
.BR \-lt ,
.BR \-le ,
.BR \-gt ,
or
.BR \-ge .
These arithmetic binary operators return true if \fIarg1\fP
is equal, not-equal, less-than, less-than-or-equal,
greater-than, or greater-than-or-equal than \fIarg2\fP,
respectively.
.I Arg1
and
.I arg2
may be positive integers, negative integers, or the special
expression \fB\-l\fP \fIstring\fP, which evaluates to the
length of 
.IR string .
.PD
.RE
.TP
\fBumask\fP [ \fImask\^\fP ]
The user file-creation mask is set to
.I mask
(see
.IR umask (2)).
.I mask
must be an octal number.
If
.I mask
is omitted, the current value of the mask is printed.
.TP
\fBunalias\fP \fIname\^\fP .\|.\|.
The
.IR
parameters
given by the list of
.IR name s
are removed from the
.I alias
list.
.TP
\fBunfunction\fP \fIname\fP .\|.\|.
The
.IR
functions
given by the list of
.IR name s
are removed from the
.I function
list.
.TP
\fBunhash\fP \fIname\fP .\|.\|.
Removes \fIname\fP from the command hash table.
Shell builtins may be undefined in this way.
.TP
\fBunlimit [ \fB\-h\fP ] [ \fIresource\fP .\|.\|. ]\fP
Remove a limitation on
.IR resource .
If no
.I resource
is specified, then all
.I resource
limitations are removed.
See the description of the
.B limit
command for the list of
.I resource
names.
.RS
.TP 8
.B \-h
Remove corresponding hard limits.  Only the super-user may do this.
.RE
.TP
\fBunset\fP \fIname\^\fP .\|.\|.
The parameters given by the list of
.IR name s
are unset.
.TP
\fBunsetopt\fP [ \fIopt\fP .\|.\|.\| ]
The named options are unset.  See \fBsetopt\fP above.
.SS Invocation
The shell first executes the the file
\fB/etc/zshrc\fP
and then
\fB\(ap/.zshrc\fP,
if it exists.
If the shell is invoked by
.IR exec (2),
and the first character of argument zero
.RB ( $0 )
is
.BR \- ,
then the shell is assumed to be a
.I login
shell and
commands are read from
.B /etc/zlogin
and
.BR \(ap/.zshrc ,
if it exists.
If the
.B \-s
flag is not present and
.I arg
is, then the first
.I arg
is taken as the name of the script to execute.
The script
.I arg
must have read permission and any
.I setuid
and
.I getgid
settings will be ignored.
Commands are then read as described below;
the following flags are interpreted by the shell
when it is invoked:
.PP
.PD 0
.TP 10
.BI \-c "\| string"
If the
.B \-c
flag is present then
commands are read from
.IR string .
.TP
.B \-s
If the
.B \-s
flag is present or if no
arguments remain
then commands are read from the standard input.
Shell output,
except for the output of the
.I builtins
listed above,
is written to
file descriptor 2.
.TP
.B \-i
If the
.B \-i
flag is present or
if the shell input and output are attached to a terminal (as told by
.IR ioctl (2))
then this shell is
.IR interactive .
In this case TERM is ignored (so that \fBkill 0\fP
does not kill an interactive shell) and INTR is caught and ignored.
In all cases, QUIT is ignored by the shell.
.PD
.PP
The remaining flags and arguments are described under the
.B setopt
command above.
.SH EXIT STATUS
Errors detected by the shell, such as syntax errors,
cause the shell
to return a non-zero exit status.
Otherwise, the shell returns the exit status of
the last command executed (see also the
.B exit
command above).
If the shell is being used non-interactively
then execution of the shell file is abandoned.
.SH FILES
\(ap/.zshrc
.br
\(ap/.zlogin
.br
\(ap/.zlogout
.br
\(ap/.zfriends
.br
\(ap/.inputrc
.br
/etc/zshrc
.br
/etc/zlogin
.br
/tmp/zsh\(**
.SH SEE ALSO
sh(1),
csh(1),
tcsh(1),
itcsh(1),
bash(1),
ksh(1),
cat(1),
cd(1),
chmod(1),
cut(1),
echo(1),
emacs(1),
env(1),
gmacs(1),
newgrp(1),
stty(1),
test(1),
umask(1),
vi(1),
dup(2),
exec(2),
fork(2),
ioctl(2),
lseek(2),
paste(1),
pipe(2),
signal(2),
umask(2),
ulimit(2),
wait(2),
rand(3),
a.out(5),
profile(5),
environ(7),
xtetris(6).
.SH AUTHOR
Paul Falstad <pfalstad@phoenix.princeton.edu>
.PP
The command line editor is a hacked-up version
of the GNU readline library,
written by Brian Fox (<bfox@ai.MIT.Edu>) of the Free
Software Foundation.  This shell is therefore
under the GNU public license.  I eventually plan
to write my own command line editor to make everything
my own code, but \fBzsh\fP will probably still be under
the GPL, or perhaps something less restrictive.
.SH CAVEATS
.PP
Using
.B fc
built-in command within a compound command will cause the whole
command to disappear from the history file.
.PP
Shell functions are put in the function table when their declarations
are parsed, not when they are executed.  Thus function declarations
inside \fBif\fP clauses, for example, will not work as expected.
(This is a bug, not a caveat.)
.PP
The command line editor gets confused if you have termcap sequences
(like %S) in your prompt.
.PP
The main shell does not get along with the command line editor.
One of them will have to go.
.PP
Use of this shell is reserved for faculty, staff,
graduate students,
and special guests
of the Princeton University 
Computer Science department.
